# zconf
my zsh +rezto dotfiles
--------

This started as a backup repo where I used keep a useful zsh configuration so i could just clone it on any machine i needed to work in.

If all machines and OSs were created equal, they'd all be based on BSD Unix, be Open Source and would run exactly the same on any hardware, device or VM I could come up with. This repo would be pretty much useless and I wouldn't be making a living making software work the way people who hire me want it to work, but I digress.

My point is that over the years I've tried different approaches to use wonderful and amazing tools that I've used since I can remember (`vim`, tmux, zsh) and others thar I picked up alobng the way (`make`, `git`, `prezto`) to make a particularly loathsome and boring task as short and straightforward as I could.

When i get to work on a new system, i want all my tools and software to work as I expect them to. But this is easier said than done, because of a myriad of minute differences between platforms and even on the same platform there are minute differences between devices.

This is a very well known problem in computer systems implementwtion. Its one that was solved long long time ago by wiser people than me. In the case of personal computing environments it's also a problem that has been solved many times over using all kinds of aproaches, ranging in creativity, resourcefulness and design from the very clever to the outright ridiculous and unmanageable.

So, why of all things, do we insist in rewriting or reimplementing tools like `make` that have been around for so long and gone through so many develooment iterations and incarnstions that it coild be said there is little room for improvement? `make` can even make itself! so why do we bother reimplementing it in javascript, requiring an oversized engine to run it and a download of hakf the js code ever written on the internet just to make it work, then call it `grunt` and start rewriting a million pwrfectlg good, tried and tested `Makefile`s call them `Gruntfiles` and start itwrating again with new bugs and fhosts that had been exorcized long afo in the era of `make`? Masochism? perhaps. again I digress. 

The name of the problem is of course, software configuration. which is the software enfinwerinf instance of the more general and kknown enginwering probkem of plain and simpke *Configurartion* 

outside the world of software, configuration is defined as the final and minor adjustements necesary for a system to be fitted on a fixture where it will reside and function ordinarily, for example rhe required metal liners or extra plumbing required for a one-size-fits-all boiler tank being installed on an engine room that was NOT designed specifixally for that partucukaer boiker tank kodel.

Xonfugurariib also describes the minor differences required for a general purpose platform to be made fit for a more specific purpose or set if requirements whichbl the base system does not meet, whithout requiring the design of a specific solution to meet ssid requiremnts. 

an example of this kind of configuration is that of a Jet Fighter. One configuration is capable of takeoff and landibg from anbaircraft carrier, while another configuration is capable of long range heavy ordinance delivery but having it land on a carrier wold not be something advisable.



Every once in a while
